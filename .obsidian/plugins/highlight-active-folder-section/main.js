/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FolderHighlighter
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  autoScroll: true,
  useImportantTags: false,
  highlightedFolderColor: "#eeeeee",
  highlightFolderTitleColor: false,
  highlightedFolderTitleColor: "#ffffff00",
  highlightedFolderTextColor: "#000000",
  highlightParentFolder: false,
  highlightedParentFolderColor: "#dddddd",
  highlightedParentFolderTextColor: "#000000",
  highlightedFolderBorderRadius: "5px",
  highlightedParentFolderBorderRadius: "5px",
  highlightedFolderFontWeight: "bold",
  highlightedParentFolderFontWeight: "bold"
};
var FolderHighlighter = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.styleEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new FolderHighlighterSettingTab(this.app, this));
    this.updateStyles();
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        this.handleReveal();
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.highlightFolders();
      })
    );
    this.app.workspace.onLayoutReady(() => {
      this.highlightFolders();
    });
  }
  handleReveal() {
    if (this.debounceTimer)
      clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => {
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      this.revealActiveFileInExplorer();
    }, 150);
  }
  /*private handleHighlight() {
  	const file = this.app.workspace.getActiveFile();
  	if (!file) return;
  	this.highlightFolders();
  } */
  async revealActiveFileInExplorer() {
    try {
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      const leaf = this.app.workspace.getLeavesOfType("file-explorer")[0];
      if (!leaf)
        return;
      const explorer = leaf.view;
      if (typeof explorer.revealInFolder !== "function")
        return;
      if (this.revealTimeout) {
        clearTimeout(this.revealTimeout);
      }
      this.revealTimeout = setTimeout(async () => {
        try {
          await explorer.revealInFolder(file);
          await new Promise((resolve) => setTimeout(resolve, 100));
          const fileElement = document.querySelector(`[data-path="${file.path}"]`);
          if (!fileElement || !this.settings.autoScroll)
            return;
          const container = fileElement.closest(".nav-files-container");
          if (!(container instanceof HTMLElement))
            return;
          const fileHTMLElement = fileElement;
          container.scrollTo({
            top: fileHTMLElement.offsetTop - container.clientHeight / 2,
            behavior: "smooth"
          });
        } catch (error) {
          console.error("Error in reveal timeout:", error);
        }
      }, 200);
    } catch (error) {
      console.error("Error in revealActiveFileInExplorer:", error);
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateStyles();
  }
  async onunload() {
    if (this.revealTimeout)
      clearTimeout(this.revealTimeout);
    if (this.debounceTimer)
      clearTimeout(this.debounceTimer);
    if (this.styleEl)
      this.styleEl.remove();
  }
  highlightFolders() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const allFolders = document.querySelectorAll(".nav-folder");
    allFolders.forEach((folder) => {
      folder.classList.remove(
        "highlighted-folder",
        "highlighted-parent-folder",
        "highlighted-intermediate-folder"
      );
    });
    const currentFolder = this.getParentFolderElement(activeFile.path);
    if (currentFolder) {
      currentFolder.classList.add("highlighted-folder");
      if (this.settings.highlightParentFolder) {
        const rootFolder = this.getRootFolderInPath(activeFile.path);
        if (rootFolder && rootFolder !== currentFolder) {
          rootFolder.classList.add("highlighted-parent-folder");
        }
      }
    }
    const intermediateFolders = this.getIntermediateFoldersInPath(
      activeFile.path
    );
    for (const intermediateFolder of intermediateFolders) {
      if (intermediateFolder) {
        intermediateFolder.classList.add(
          "highlighted-intermediate-folder"
        );
      }
    }
  }
  getParentFolderElement(filePath) {
    const folderPaths = filePath.split("/");
    folderPaths.pop();
    let folderElement = null;
    while (folderPaths.length > 0) {
      const folderName = folderPaths.join("/");
      const possibleFolderElement = document.querySelector(
        `[data-path="${folderName}"]`
      );
      if (possibleFolderElement) {
        folderElement = possibleFolderElement.closest(".nav-folder");
        break;
      }
      folderPaths.pop();
    }
    return folderElement;
  }
  getRootFolderInPath(filePath) {
    var _a;
    const folderPaths = filePath.split("/");
    folderPaths.pop();
    if (folderPaths.length > 0) {
      const rootFolderName = folderPaths[0];
      return ((_a = document.querySelector(`[data-path="${rootFolderName}"]`)) == null ? void 0 : _a.closest(".nav-folder")) || null;
    }
    return null;
  }
  getIntermediateFoldersInPath(filePath) {
    const intermediateFolders = [];
    const folderPaths = filePath.split("/");
    folderPaths.pop();
    while (folderPaths.length > 1) {
      const folderName = folderPaths.join("/");
      const folderElement = document.querySelector(
        `[data-path="${folderName}"]`
      );
      if (folderElement) {
        intermediateFolders.push(folderElement.closest(".nav-folder"));
      }
      folderPaths.pop();
    }
    return intermediateFolders;
  }
  updateStyles() {
    if (!this.styleEl) {
      this.styleEl = document.createElement("style");
      this.styleEl.id = "folder-highlighter-styles";
      document.head.appendChild(this.styleEl);
    }
    const important = this.settings.useImportantTags ? " !important" : "";
    const styleContent = `
            .highlighted-folder {
                background-color: ${this.settings.highlightedFolderColor}${important};
                border-radius: ${this.settings.highlightedFolderBorderRadius}${important};
            }
            .highlighted-folder > .nav-folder-title {
                ${this.settings.highlightFolderTitleColor ? `background-color: ${this.settings.highlightedFolderTitleColor}${important};` : ""}
                color: ${this.settings.highlightedFolderTextColor}${important};
                border-radius: ${this.settings.highlightedFolderBorderRadius}${important};
                font-weight: ${this.settings.highlightedFolderFontWeight}${important};
            }
            .highlighted-parent-folder {
                background-color: ${this.settings.highlightedParentFolderColor}${important};
                border-radius: ${this.settings.highlightedParentFolderBorderRadius}${important};
            }
            .highlighted-parent-folder > .nav-folder-title {
                color: ${this.settings.highlightedParentFolderTextColor}${important};
                font-weight: ${this.settings.highlightedParentFolderFontWeight}${important};
                border-radius: ${this.settings.highlightedParentFolderBorderRadius}${important};
            }
            .highlighted-folder > .nav-folder-title:hover,
            .highlighted-folder > .nav-folder-title.is-being-dragged,
            .highlighted-parent-folder > .nav-folder-title:hover,
            .highlighted-parent-folder > .nav-folder-title.is-being-dragged {
                font-weight: ${this.settings.highlightedFolderFontWeight}${important};
            }
            .highlighted-folder .nav-file-title.is-active {
                font-weight: ${this.settings.highlightedFolderFontWeight}${important};
            }
            .highlighted-parent-folder .nav-file-title.is-active {
                font-weight: ${this.settings.highlightedParentFolderFontWeight}${important};
            }
        `;
    this.styleEl.textContent = styleContent;
  }
};
var FolderHighlighterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Overrides theme settings").setDesc(
      "Enable this to override theme styles with !important tags."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useImportantTags).onChange(async (value) => {
        this.plugin.settings.useImportantTags = value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto scroll to active file").setDesc("Automatically scroll the file explorer to the active file").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoScroll).onChange(async (value) => {
      this.plugin.settings.autoScroll = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Active folder").setHeading();
    const createColorSetting = (name, desc, key) => {
      const savedColor = this.plugin.settings[key];
      let alphaValue = 1;
      if (typeof savedColor === "string") {
        const match2 = savedColor.match(
          /rgba\((\d+), (\d+), (\d+), ([\d.]+)\)/
        );
        if (match2) {
          alphaValue = parseFloat(match2[4]);
        }
      }
      const match = savedColor.match(
        /rgba\((\d+), (\d+), (\d+), ([\d.]+)\)/
      );
      if (match) {
        alphaValue = parseFloat(match[4]);
      }
      new import_obsidian.Setting(containerEl).setName(name).setDesc(desc).addText((text) => {
        var _a, _b, _c;
        text.setPlaceholder("#eeeeee").setValue(savedColor.toString()).onChange(async (value) => {
          this.plugin.settings[key] = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.classList.add("input-width-150");
        const colorPicker = document.createElement("input");
        colorPicker.type = "color";
        const rgbColor = this.extractRgbFromRgba(
          savedColor.toString()
        );
        colorPicker.value = this.rgbToHex(rgbColor);
        colorPicker.title = "Choose a color";
        colorPicker.addEventListener(
          "input",
          async (event) => {
            const value = event.target.value;
            const rgb = this.hexToRgb(value);
            this.plugin.settings[key] = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alphaValue})`;
            await this.plugin.saveSettings();
            text.setValue(this.plugin.settings[key]);
          }
        );
        (_a = text.inputEl.parentElement) == null ? void 0 : _a.appendChild(colorPicker);
        const transparencySlider = document.createElement("input");
        transparencySlider.type = "range";
        transparencySlider.min = "0";
        transparencySlider.max = "1";
        transparencySlider.step = "0.01";
        transparencySlider.value = alphaValue.toString();
        transparencySlider.classList.add("margin-left-10");
        transparencySlider.title = "Move the slider to adjust transparency";
        transparencySlider.addEventListener(
          "input",
          async (event) => {
            alphaValue = parseFloat(event.target.value);
            const rgb = this.hexToRgb(colorPicker.value);
            this.plugin.settings[key] = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alphaValue})`;
            await this.plugin.saveSettings();
            text.setValue(this.plugin.settings[key]);
          }
        );
        (_b = text.inputEl.parentElement) == null ? void 0 : _b.appendChild(transparencySlider);
        const resetButton = document.createElement("button");
        resetButton.textContent = "Reset";
        resetButton.title = "Reset to previous color";
        resetButton.classList.add("margin-left-10");
        resetButton.addEventListener("click", async () => {
          this.plugin.settings[key] = savedColor;
          await this.plugin.saveSettings();
          const rgbColor2 = this.extractRgbFromRgba(
            savedColor.toString()
          );
          colorPicker.value = this.rgbToHex(rgbColor2);
          const alpha = this.extractAlphaFromRgba(
            savedColor.toString()
          );
          transparencySlider.value = alpha.toString();
          text.setValue(savedColor.toString());
        });
        (_c = text.inputEl.parentElement) == null ? void 0 : _c.appendChild(resetButton);
      });
    };
    createColorSetting(
      "Folder section background-color",
      "Choose a background-color of the active folder-container.",
      "highlightedFolderColor"
    );
    new import_obsidian.Setting(containerEl).setName("Folder background color").setDesc("Enable background-color of the folder title.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.highlightFolderTitleColor).onChange(async (value) => {
        this.plugin.settings.highlightFolderTitleColor = value;
        if (!value) {
          this.plugin.settings.highlightedFolderTitleColor = "#ffffff00";
        }
        await this.plugin.saveSettings();
        this.display();
        this.plugin.updateStyles();
      })
    );
    if (this.plugin.settings.highlightFolderTitleColor) {
      createColorSetting(
        "Folder background-color",
        "Choose a color for the highlighted folder title.",
        "highlightedFolderTitleColor"
      );
    }
    createColorSetting(
      "Folder text color",
      "Choose a color for the highlighted folder text.",
      "highlightedFolderTextColor"
    );
    new import_obsidian.Setting(containerEl).setName("Highlighted folder font weight").setDesc("Set the font weight of the highlighted folder titles.").addDropdown(
      (dropdown) => dropdown.addOption("200", "Thin").addOption("400", "Normal").addOption("700", "Bold").setValue(
        this.plugin.settings.highlightedFolderFontWeight || "700"
      ).onChange(async (value) => {
        this.plugin.settings.highlightedFolderFontWeight = value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Folder border radius").setDesc("Set the border radius of the highlighted folder.").addSlider(
      (slider) => slider.setLimits(0, 50, 1).setValue(
        parseInt(
          this.plugin.settings.highlightedFolderBorderRadius
        )
      ).onChange(async (value) => {
        const radiusWithPx = `${value}px`;
        this.plugin.settings.highlightedFolderBorderRadius = radiusWithPx;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      }).setDynamicTooltip()
      // Adds a tooltip showing the current value
    );
    new import_obsidian.Setting(containerEl).setName("Root folder").setHeading();
    new import_obsidian.Setting(containerEl).setName("Highlight root folder").setDesc(
      "Enable background-color of the root folder segment in the path to the active note."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.highlightParentFolder).onChange(async (value) => {
        this.plugin.settings.highlightParentFolder = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.highlightParentFolder) {
      createColorSetting(
        "Root folder section background-color",
        "Choose a background-color of the root folder segment.",
        "highlightedParentFolderColor"
      );
      createColorSetting(
        "Root folder text color",
        "Choose a color for the highlighted root folder text.",
        "highlightedParentFolderTextColor"
      );
      new import_obsidian.Setting(containerEl).setName("Highlighted root folder font weight").setDesc(
        "Set the font weight of the highlighted parent folder titles."
      ).addDropdown(
        (dropdown) => dropdown.addOption("200", "Thin").addOption("400", "Normal").addOption("700", "Bold").setValue(
          this.plugin.settings.highlightedParentFolderFontWeight || "700"
        ).onChange(async (value) => {
          this.plugin.settings.highlightedParentFolderFontWeight = value;
          await this.plugin.saveSettings();
          this.plugin.updateStyles();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Root folder border radius").setDesc(
        "Set the border radius of the highlighted root folder."
      ).addSlider(
        (slider) => slider.setLimits(0, 50, 1).setValue(
          parseInt(
            this.plugin.settings.highlightedParentFolderBorderRadius
          )
        ).onChange(async (value) => {
          const radiusWithPx = `${value}px`;
          this.plugin.settings.highlightedParentFolderBorderRadius = radiusWithPx;
          await this.plugin.saveSettings();
          this.plugin.updateStyles();
        }).setDynamicTooltip()
      );
    }
  }
  // Helper function to convert hex color to RGB
  hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = bigint >> 16 & 255;
    const g = bigint >> 8 & 255;
    const b = bigint & 255;
    return { r, g, b };
  }
  // Helper function to extract RGB values from RGBA string
  extractRgbFromRgba(rgba) {
    const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
      return {
        r: parseInt(match[1]),
        g: parseInt(match[2]),
        b: parseInt(match[3])
      };
    }
    return { r: 0, g: 0, b: 0 };
  }
  // Helper function to extract alpha value from RGBA string
  extractAlphaFromRgba(rgba) {
    const match = rgba.match(/rgba?\(.*?,\s*([\d.]+)\)/);
    return match ? parseFloat(match[1]) : 1;
  }
  // Helper function to convert RGB to HEX
  rgbToHex(rgb) {
    return "#" + ((1 << 24) + (rgb.r << 16) + (rgb.g << 8) + rgb.b).toString(16).slice(1);
  }
};


/* nosourcemap */