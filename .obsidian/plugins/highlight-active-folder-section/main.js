/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FolderHighlighter
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  autoScroll: true,
  useImportantTags: false,
  // Light Theme Defaults
  lightHighlightedFolderColor: "rgba(238, 238, 238, 1)",
  lightHighlightFolderTitleColor: false,
  lightHighlightedFolderTitleColor: "rgba(255, 255, 255, 0)",
  lightHighlightedFolderTextColor: "rgba(0, 0, 0, 1)",
  lightHighlightedParentFolderColor: "rgba(221, 221, 221, 1)",
  lightHighlightedParentFolderTextColor: "rgba(0, 0, 0, 1)",
  previousLightHighlightedFolderTitleColor: "rgba(255, 255, 255, 0.8)",
  // Dark Theme Defaults
  darkHighlightedFolderColor: "rgba(51, 51, 51, 1)",
  darkHighlightFolderTitleColor: false,
  darkHighlightedFolderTitleColor: "rgba(51, 51, 51, 1)",
  darkHighlightedFolderTextColor: "rgba(255, 255, 255, 1)",
  darkHighlightedParentFolderColor: "rgba(68, 68, 68, 1)",
  darkHighlightedParentFolderTextColor: "rgba(255, 255, 255, 1)",
  previousDarkHighlightedFolderTitleColor: "rgba(51, 51, 51, 1)",
  // Shared Settings
  highlightParentFolder: false,
  highlightedFolderBorderRadius: "5px",
  highlightedParentFolderBorderRadius: "5px",
  highlightedFolderFontWeight: "bold",
  highlightedParentFolderFontWeight: "bold",
  // UI State - automatisch den aktuellen Theme-Modus erkennen
  editingDarkTheme: document.body.classList.contains("theme-dark")
};
var FolderHighlighter = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.styleEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new FolderHighlighterSettingTab(this.app, this));
    this.updateStyles();
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        this.handleReveal();
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.highlightFolders();
      })
    );
    this.app.workspace.onLayoutReady(() => {
      setTimeout(() => {
        console.log("Attempting to highlight active file...");
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          console.log("No active file found");
          return;
        }
        console.log("Active file:", activeFile.path);
        console.log("Triggering events programmatically...");
        this.app.workspace.trigger("file-open", activeFile);
        this.app.workspace.trigger(
          "active-leaf-change",
          this.app.workspace.activeLeaf
        );
        setTimeout(() => {
          this.highlightFolders();
          console.log(
            "Manually triggered highlightFolders after events"
          );
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (activeView && activeView.editor) {
            activeView.editor.focus();
          }
        }, 200);
      }, 1500);
    });
  }
  handleReveal() {
    if (this.debounceTimer)
      clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => {
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      this.revealActiveFileInExplorer();
    }, 150);
  }
  async revealActiveFileInExplorer() {
    try {
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      const leaf = this.app.workspace.getLeavesOfType("file-explorer")[0];
      if (!leaf)
        return;
      const explorer = leaf.view;
      if (typeof explorer.revealInFolder !== "function")
        return;
      if (this.revealTimeout) {
        clearTimeout(this.revealTimeout);
      }
      this.revealTimeout = setTimeout(async () => {
        try {
          await new Promise((resolve) => setTimeout(resolve, 100));
          const fileElement = document.querySelector(
            `[data-path="${file.path}"]`
          );
          if (!fileElement || !this.settings.autoScroll)
            return;
          const container = fileElement.closest(
            ".nav-files-container"
          );
          if (!(container instanceof HTMLElement))
            return;
          const fileHTMLElement = fileElement;
          container.scrollTo({
            top: fileHTMLElement.offsetTop - container.clientHeight / 2,
            behavior: "smooth"
          });
        } catch (error) {
          console.error("Error in reveal timeout:", error);
        }
      }, 200);
    } catch (error) {
      console.error("Error in revealActiveFileInExplorer:", error);
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateStyles();
  }
  async onunload() {
    if (this.revealTimeout)
      clearTimeout(this.revealTimeout);
    if (this.debounceTimer)
      clearTimeout(this.debounceTimer);
    if (this.styleEl)
      this.styleEl.remove();
  }
  highlightFolders() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      this.clearHighlight();
      return;
    }
    const allFolders = document.querySelectorAll(".nav-folder");
    allFolders.forEach((folder) => {
      folder.classList.remove(
        "highlighted-folder",
        "highlighted-parent-folder",
        "highlighted-intermediate-folder"
      );
    });
    const currentFolder = this.getParentFolderElement(activeFile.path);
    if (currentFolder) {
      currentFolder.classList.add("highlighted-folder");
      if (this.settings.highlightParentFolder) {
        const rootFolder = this.getRootFolderInPath(activeFile.path);
        if (rootFolder && rootFolder !== currentFolder) {
          rootFolder.classList.add("highlighted-parent-folder");
        }
      }
      const intermediateFolders = this.getIntermediateFoldersInPath(
        activeFile.path
      );
      for (const intermediateFolder of intermediateFolders) {
        if (intermediateFolder && intermediateFolder !== currentFolder && (!this.settings.highlightParentFolder || intermediateFolder !== this.getRootFolderInPath(activeFile.path))) {
          intermediateFolder.classList.add(
            "highlighted-intermediate-folder"
          );
        }
      }
    }
  }
  clearHighlight() {
    document.querySelectorAll(".highlighted-folder").forEach((el) => {
      el.classList.remove(
        "highlighted-folder",
        "highlighted-parent-folder"
      );
    });
  }
  getParentFolderElement(filePath) {
    const folderPaths = filePath.split("/");
    folderPaths.pop();
    let folderElement = null;
    while (folderPaths.length > 0) {
      const folderName = folderPaths.join("/");
      const possibleFolderElement = document.querySelector(
        `[data-path="${folderName}"]`
      );
      if (possibleFolderElement) {
        folderElement = possibleFolderElement.closest(".nav-folder");
        break;
      }
      folderPaths.pop();
    }
    return folderElement;
  }
  getRootFolderInPath(filePath) {
    var _a;
    const folderPaths = filePath.split("/");
    folderPaths.pop();
    if (folderPaths.length > 0) {
      const rootFolderName = folderPaths[0];
      return ((_a = document.querySelector(`[data-path="${rootFolderName}"]`)) == null ? void 0 : _a.closest(".nav-folder")) || null;
    }
    return null;
  }
  getIntermediateFoldersInPath(filePath) {
    const intermediateFolders = [];
    const folderPaths = filePath.split("/");
    folderPaths.pop();
    while (folderPaths.length > 1) {
      const folderName = folderPaths.join("/");
      const folderElement = document.querySelector(
        `[data-path="${folderName}"]`
      );
      if (folderElement) {
        intermediateFolders.push(folderElement.closest(".nav-folder"));
      }
      folderPaths.pop();
    }
    return intermediateFolders;
  }
  updateStyles() {
    const rootEl = document.documentElement;
    const important = this.settings.useImportantTags ? " !important" : "";
    rootEl.style.setProperty(
      "--light-highlighted-folder-color",
      this.settings.lightHighlightedFolderColor
    );
    rootEl.style.setProperty(
      "--light-highlighted-folder-title-color",
      this.settings.lightHighlightedFolderTitleColor
    );
    rootEl.style.setProperty(
      "--light-highlighted-folder-text-color",
      this.settings.lightHighlightedFolderTextColor
    );
    rootEl.style.setProperty(
      "--light-highlighted-parent-folder-color",
      this.settings.lightHighlightedParentFolderColor
    );
    rootEl.style.setProperty(
      "--light-highlighted-parent-folder-text-color",
      this.settings.lightHighlightedParentFolderTextColor
    );
    rootEl.style.setProperty(
      "--dark-highlighted-folder-color",
      this.settings.darkHighlightedFolderColor
    );
    rootEl.style.setProperty(
      "--dark-highlighted-folder-title-color",
      this.settings.darkHighlightedFolderTitleColor
    );
    rootEl.style.setProperty(
      "--dark-highlighted-folder-text-color",
      this.settings.darkHighlightedFolderTextColor
    );
    rootEl.style.setProperty(
      "--dark-highlighted-parent-folder-color",
      this.settings.darkHighlightedParentFolderColor
    );
    rootEl.style.setProperty(
      "--dark-highlighted-parent-folder-text-color",
      this.settings.darkHighlightedParentFolderTextColor
    );
    rootEl.style.setProperty(
      "--highlighted-folder-border-radius",
      `${this.settings.highlightedFolderBorderRadius}${important}`
    );
    rootEl.style.setProperty(
      "--highlighted-parent-folder-border-radius",
      `${this.settings.highlightedParentFolderBorderRadius}`
    );
    rootEl.style.setProperty(
      "--highlighted-folder-font-weight",
      `${this.settings.highlightedFolderFontWeight}${important}`
    );
    rootEl.style.setProperty(
      "--highlighted-parent-folder-font-weight",
      `${this.settings.highlightedParentFolderFontWeight}${important}`
    );
    const borderRadiusValue = parseInt(
      this.settings.highlightedParentFolderBorderRadius
    );
    if (borderRadiusValue > 30) {
      rootEl.style.setProperty("--parent-folder-padding", "7px");
    } else {
      rootEl.style.setProperty("--parent-folder-padding", "3px");
    }
    const styleSheet = document.createElement("style");
    styleSheet.textContent = `
			.highlighted-folder > .nav-folder-title {
				font-weight: ${this.settings.highlightedFolderFontWeight}${important};
				border-radius: ${this.settings.highlightedFolderBorderRadius}${important};
			}
			.highlighted-parent-folder > .nav-folder-title {
				font-weight: ${this.settings.highlightedParentFolderFontWeight}${important};
				border-radius: ${this.settings.highlightedParentFolderBorderRadius}${important};
			}
		`;
    document.head.appendChild(styleSheet);
    if (this.settings.useImportantTags) {
      const addImportant = (variable) => {
        const value = getComputedStyle(rootEl).getPropertyValue(variable);
        if (value && !value.includes("!important")) {
          rootEl.style.setProperty(variable, value + " !important");
        }
      };
      [
        "--light-highlighted-folder-color",
        "--light-highlighted-folder-title-color",
        "--light-highlighted-folder-text-color",
        "--light-highlighted-parent-folder-color",
        "--light-highlighted-parent-folder-text-color",
        "--dark-highlighted-folder-color",
        "--dark-highlighted-folder-title-color",
        "--dark-highlighted-folder-text-color",
        "--dark-highlighted-parent-folder-color",
        "--dark-highlighted-parent-folder-text-color"
      ].forEach(addImportant);
    }
  }
};
var FolderHighlighterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.colorSettings = [];
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.colorSettings = [];
    const themeHeaderEl = containerEl.createEl("div", {
      cls: "theme-header"
    });
    themeHeaderEl.createEl("h2", {
      text: this.plugin.settings.editingDarkTheme ? "Dark Theme" : "Light Theme",
      cls: "theme-title"
    });
    this.themeToggleButton = themeHeaderEl.createEl("div", {
      cls: "theme-toggle-button"
    });
    this.updateThemeToggleIcon();
    this.themeToggleButton.addEventListener("click", async () => {
      this.containerEl.addClass("theme-transition");
      this.plugin.settings.editingDarkTheme = !this.plugin.settings.editingDarkTheme;
      await this.plugin.saveSettings();
      setTimeout(() => {
        this.display();
        setTimeout(() => {
          this.containerEl.removeClass("theme-transition");
        }, 850);
      }, 150);
    });
    this.createGeneralSettings(containerEl);
    this.createActiveFolderSettings(containerEl);
    this.createRootFolderSettings(containerEl);
  }
  createGeneralSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Override theme styles").setDesc("Use !important for style definitions").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useImportantTags).onChange(async (value) => {
        this.plugin.settings.useImportantTags = value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto scroll").setDesc("Automatically scroll to active file").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoScroll).onChange(async (value) => {
        this.plugin.settings.autoScroll = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createActiveFolderSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Active Folder").setHeading();
    const settingContainer = containerEl.createEl("div", {
      cls: "setting-indent"
    });
    new import_obsidian.Setting(settingContainer).setName("Enable title background").setDesc("Show background color for folder titles").addToggle(
      (toggle) => toggle.setValue(
        this.getCurrentThemeSetting("HighlightFolderTitleColor")
      ).onChange(async (value) => {
        this.setThemeSetting(
          "HighlightFolderTitleColor",
          value
        );
        if (!value) {
          this.plugin.settings.previousLightHighlightedFolderTitleColor = this.plugin.settings.lightHighlightedFolderTitleColor;
          this.plugin.settings.previousDarkHighlightedFolderTitleColor = this.plugin.settings.darkHighlightedFolderTitleColor;
          this.plugin.settings.lightHighlightedFolderTitleColor = "rgba(0, 0, 0, 0)";
          this.plugin.settings.darkHighlightedFolderTitleColor = "rgba(0, 0, 0, 0)";
        } else {
          if (this.plugin.settings.previousLightHighlightedFolderTitleColor && this.plugin.settings.previousLightHighlightedFolderTitleColor !== "rgba(0, 0, 0, 0)") {
            this.plugin.settings.lightHighlightedFolderTitleColor = this.plugin.settings.previousLightHighlightedFolderTitleColor;
          } else {
            this.plugin.settings.lightHighlightedFolderTitleColor = DEFAULT_SETTINGS.lightHighlightedFolderTitleColor;
          }
          if (this.plugin.settings.previousDarkHighlightedFolderTitleColor && this.plugin.settings.previousDarkHighlightedFolderTitleColor !== "rgba(0, 0, 0, 0)") {
            this.plugin.settings.darkHighlightedFolderTitleColor = this.plugin.settings.previousDarkHighlightedFolderTitleColor;
          } else {
            this.plugin.settings.darkHighlightedFolderTitleColor = DEFAULT_SETTINGS.darkHighlightedFolderTitleColor;
          }
        }
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
        this.plugin.highlightFolders();
        this.display();
      })
    );
    if (this.getCurrentThemeSetting("HighlightFolderTitleColor")) {
      this.createColorSetting(
        settingContainer,
        "Title background color",
        "Color for folder title background",
        "HighlightedFolderTitleColor"
      );
    }
    this.createColorSetting(
      settingContainer,
      "Folder background",
      "Background color for folder container",
      "HighlightedFolderColor"
    );
    this.createColorSetting(
      settingContainer,
      "Text color",
      "Color for folder items",
      "HighlightedFolderTextColor"
    );
    new import_obsidian.Setting(settingContainer).setName("Font weight").setDesc("Font weight for folder titles").addDropdown(
      (dropdown) => dropdown.addOptions({
        "200": "Thin",
        "400": "Normal",
        "700": "Bold"
      }).setValue(this.plugin.settings.highlightedFolderFontWeight).onChange(async (value) => {
        this.plugin.settings.highlightedFolderFontWeight = value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      })
    );
    new import_obsidian.Setting(settingContainer).setName("Border radius").setDesc("Corner rounding for folders").addSlider(
      (slider) => slider.setLimits(0, 50, 1).setValue(
        parseInt(
          this.plugin.settings.highlightedFolderBorderRadius
        )
      ).onChange(async (value) => {
        this.plugin.settings.highlightedFolderBorderRadius = `${value}px`;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      }).setDynamicTooltip()
    );
  }
  createRootFolderSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Root Folder").setHeading();
    new import_obsidian.Setting(containerEl).setName("Highlight root folders").setDesc("Enable special styling for root folders").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.highlightParentFolder).onChange(async (value) => {
        this.plugin.settings.highlightParentFolder = value;
        await this.plugin.saveSettings();
        this.plugin.highlightFolders();
        this.display();
      })
    );
    if (this.plugin.settings.highlightParentFolder) {
      const settingContainer = containerEl.createEl("div", {
        cls: "setting-indent"
      });
      this.createColorSetting(
        settingContainer,
        "Root background",
        "Background color for root folders",
        "HighlightedParentFolderColor"
      );
      this.createColorSetting(
        settingContainer,
        "Root text color",
        "Text color for root folders",
        "HighlightedParentFolderTextColor"
      );
      new import_obsidian.Setting(settingContainer).setName("Root font weight").setDesc("Font weight for root folders").addDropdown(
        (dropdown) => dropdown.addOptions({
          "200": "Thin",
          "400": "Normal",
          "700": "Bold"
        }).setValue(
          this.plugin.settings.highlightedParentFolderFontWeight
        ).onChange(async (value) => {
          this.plugin.settings.highlightedParentFolderFontWeight = value;
          await this.plugin.saveSettings();
          this.plugin.updateStyles();
        })
      );
      new import_obsidian.Setting(settingContainer).setName("Root border radius").setDesc("Corner rounding for root folders").addSlider(
        (slider) => slider.setLimits(0, 50, 1).setValue(
          parseInt(
            this.plugin.settings.highlightedParentFolderBorderRadius
          )
        ).onChange(async (value) => {
          this.plugin.settings.highlightedParentFolderBorderRadius = `${value}px`;
          await this.plugin.saveSettings();
          this.plugin.updateStyles();
        }).setDynamicTooltip()
      );
    }
  }
  createColorSetting(containerEl, name, desc, baseKey) {
    const prefix = this.plugin.settings.editingDarkTheme ? "dark" : "light";
    const key = `${prefix}${baseKey}`;
    const value = this.plugin.settings[key];
    const defaultKey = `${prefix}${baseKey}`;
    const defaultValue = DEFAULT_SETTINGS[defaultKey];
    const rgba = this.extractRgbaComponents(value);
    const alpha = rgba.a;
    const settingEl = new import_obsidian.Setting(containerEl).setName(name).setDesc(desc).addColorPicker(
      (color) => color.setValue(this.rgbToHex(rgba)).onChange(async (newColor) => {
        const newRgb = this.hexToRgb(newColor);
        const newRgba = `rgba(${newRgb.r}, ${newRgb.g}, ${newRgb.b}, ${alpha})`;
        this.plugin.settings[key] = newRgba;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      })
    ).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default value").onClick(async () => {
        this.plugin.settings[key] = defaultValue;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
        this.display();
      })
    );
    this.colorSettings.push(settingEl.settingEl);
    const transparencyContainer = containerEl.createEl("div", {
      cls: "transparency-slider-container"
    });
    transparencyContainer.createEl("div", {
      cls: "setting-item-info",
      text: "Transparency"
    });
    const slider = transparencyContainer.createEl("input", {
      cls: "transparency-slider",
      attr: {
        type: "range",
        min: "0",
        max: "100",
        value: Math.round((1 - alpha) * 100).toString()
      }
    });
    const valueDisplay = transparencyContainer.createEl("span", {
      cls: "transparency-value",
      text: `${Math.round((1 - alpha) * 100)}%`
    });
    slider.addEventListener("input", async (e) => {
      const target = e.target;
      const transparencyValue = parseInt(target.value);
      const newAlpha = 1 - transparencyValue / 100;
      valueDisplay.textContent = `${transparencyValue}%`;
      const currentRgba = this.extractRgbaComponents(
        this.plugin.settings[key]
      );
      const newRgba = `rgba(${currentRgba.r}, ${currentRgba.g}, ${currentRgba.b}, ${newAlpha})`;
      this.plugin.settings[key] = newRgba;
      await this.plugin.saveSettings();
      this.plugin.updateStyles();
    });
    return settingEl;
  }
  // Helper-Methoden für die Farbverarbeitung
  extractRgbaComponents(rgba) {
    const match = rgba.match(
      /rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/
    );
    if (match) {
      return {
        r: parseInt(match[1]),
        g: parseInt(match[2]),
        b: parseInt(match[3]),
        a: match[4] ? parseFloat(match[4]) : 1
      };
    }
    return { r: 0, g: 0, b: 0, a: 1 };
  }
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  rgbToHex(rgba) {
    return "#" + ((1 << 24) + (rgba.r << 16) + (rgba.g << 8) + rgba.b).toString(16).slice(1);
  }
  getCurrentThemeSetting(key) {
    const themeKey = this.plugin.settings.editingDarkTheme ? `dark${key}` : `light${key}`;
    return this.plugin.settings[themeKey];
  }
  setThemeSetting(key, value) {
    this.plugin.settings[`dark${key}`] = value;
    this.plugin.settings[`light${key}`] = value;
  }
  // Aktualisiert das Icon je nach Modus
  updateThemeToggleIcon() {
    this.themeToggleButton.empty();
    if (this.plugin.settings.editingDarkTheme) {
      this.themeToggleButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            `;
    } else {
      this.themeToggleButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            `;
    }
  }
  // Fügt eine Farbvergleichsanzeige hinzu
  addColorComparison(containerEl, currentColor, otherColor) {
    const comparisonEl = containerEl.createEl("div", {
      cls: "color-comparison"
    });
    comparisonEl.createSpan({
      text: `Im ${this.plugin.settings.editingDarkTheme ? "hellen" : "dunklen"} Theme: `
    });
    const colorPreview = comparisonEl.createEl("div", {
      cls: "color-preview"
    });
    colorPreview.style.backgroundColor = otherColor;
    comparisonEl.createSpan({ text: otherColor });
  }
  // Aktualisiert die Farbvergleichsanzeige
  updateColorComparison(containerEl, currentColor, otherColor) {
    const existingComparison = containerEl.querySelector(".color-comparison");
    if (existingComparison) {
      existingComparison.remove();
    }
    this.addColorComparison(containerEl, currentColor, otherColor);
  }
};

/* nosourcemap */